<?php

/**
 * @file
 * CKEditor inline image style.
 */

/**
 * Implements hook_permission().
 */
function ckeditor_inline_image_style_permission() {
  return [
    'administer ckeditor_inline_image_styles' => [
      'title'       => t('Administer CKEditor inline image styles'),
      'description' => t('Administer CKEditor inline image styles'),
    ],
  ];
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node edit forms.
 */
function ckeditor_inline_image_style_form_node_form_alter(&$form, &$form_state, $form_id) {
  // Assuming you want this to run on all node forms, but you might want to add more specific conditions.
  if (strpos($form_id, 'node_form') !== FALSE) {
    // Add your CSS for the .ImagePreviewBox.
    backdrop_add_css(
      ckeditor_inline_image_style_css('.ImagePreviewBox'),
      'inline'
    );
    // Integrate with the WYSIWYG module, and the CKEditor module.
    $image_styles = image_styles();
    $mappings = [];

    // Prepare mappings using all available image styles.
    foreach ($image_styles as $machine_name => $info) {
      $mappings[$machine_name] = $info['label'];
    }

    // Ensure there is an option for 'none'.
    $mappings = ['none' => 'Original Image'] + $mappings;

    // Prepare your JavaScript settings and add them.
    backdrop_add_js([
      'ckeditor_inline_image_style' => [
        'mappings'  => $mappings,
        //'label'     => $label,
        'editorCSS' => ckeditor_inline_image_style_css(),
      ],
    ], 'setting');

    // Adjust the path according to where you placed the ckeditor.css file.
    $path_to_css = backdrop_get_path('module', 'ckeditor_inline_image_style') . '/css/ckeditor5.css';
    // Add the CSS file.
    backdrop_add_css($path_to_css);
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for CKEditor image dialog form.
 */
function ckeditor_inline_image_style_form_filter_format_editor_image_form_alter(  &$form, $form_state) {
  // Load module configuration.
  $format = $form_state['format'];
  if ($format->editor !== 'ckeditor' && $format->editor !== 'ckeditor5') {
    return;
  }

  // Check if the custom filter is enabled for the format.
  $filter_enabled
    = !empty($format->filters['ckeditor_inline_image_style']->status);


  $values = isset($_SESSION['inline_image_styles_last_attributes']) ? $_SESSION['inline_image_styles_last_attributes'] : [];

  //$values = [];
  if (isset($form_state['input']['editor_object'])) {
    $values = $form_state['input']['editor_object'];
  }
  // Fetch available image styles and prepare options for the select element.
  $image_styles = image_styles();
  $ckeditor_mappings = $form_state['format']->editor_settings['ckeditor_inline_image_style']['image_styles'];
  $options = [
    'none' => t(
      'Original Image'
    ),
  ]; // Ensures a default, non-selected option is available.

  foreach ($ckeditor_mappings as $machine_name) {
    if (isset($image_styles[$machine_name])) {
      $label = $image_styles[$machine_name]['label'];
      $options[$machine_name]
        = $label; // Use the machine name as the key for easy mapping.
    }
  }

  // Add the select field to the form.
  $form['image_style'] = [
    '#title'              => t('Image Style'),
    '#type'               => 'select',
    '#default_value'      => isset($values['data-image-style']) ? $values['data-image-style'] : 'none',
    '#options'            => $options,
    '#wrapper_attributes' => ['class' => ['editor-data-image-style']],
    '#parents'            => ['attributes', 'data-image-style'],
    '#description'        => t('Choose the image style you want to apply.'),
    //'#weight'             => -1, // Adjust as necessary to position the element.
    '#access'             => $filter_enabled,
  ];
  // Adjust the AJAX callback for the form submission.
  $form['actions']['submit']['#ajax']['callback']
    = 'ckeditor_inline_image_style_format_editor_dialog_save';
}

/**
 * Custom save function for the image dialog form.
 */
/**
 * Custom AJAX callback function for the CKEditor image dialog form submission.
 */

function ckeditor_inline_image_style_format_editor_dialog_save($form, &$form_state) {
  // First, invoke the original dialog save function to handle standard saving operations.
  $return = filter_format_editor_dialog_save($form, $form_state);

  // Check if the data-image-style attribute is set and handle it.
  if (isset($form_state['values']['attributes']['data-image-style'])) {
    $style_name = $form_state['values']['attributes']['data-image-style'];
    // Update the command to include the data-image-style attribute.
    // This assumes there's a command in $return that sets attributes for the image.
    foreach ($return['#commands'] as &$command) {
      if ($command['command'] === 'editorDialogSave') {
        $command['values']['attributes']['data-image-style'] = $style_name;
        break; // Exit the loop once the update is made.
      }
    }

    // Store the selected image style in the session for retrieval in form_alter.
    // This session variable can be used to remember the user's last selection.
    $_SESSION['inline_image_styles_last_attributes']['data-image-style'] = $style_name;
  }

  return $return;
}

function ckeditor_inline_image_style_css($prefix = '') {
  $image_styles = image_styles(); // Load all available image styles.
  $mappings = [];

  foreach ($image_styles as $machine_name => $info) {
    if (!empty($info['effects'])) {
      // Assuming the desired dimensions are always in the first effect's data
      $effect = reset($info['effects']);
      if (isset($effect['data']['width']) && isset($effect['data']['height'])) {
        $dimensions = [
          'width' => $effect['data']['width'] . 'px', // Add 'px' unit
          'height' => $effect['data']['height'] . 'px', // Add 'px' unit
        ];

        $cssRule = $prefix . ' img[data-image-style="' . $machine_name . '"] {';
        $cssRule .= ' width: ' . $dimensions['width'] . ';';
        $cssRule .= ' height: ' . $dimensions['height'] . ';';
        $cssRule .= '}';

        $mappings[] = $cssRule; // Add the CSS rule to the mappings array.
      }
    }
  }

  return implode("\n", $mappings); // Combine all the CSS rules into one string.
}


/**
 * Implements hook_ckeditor_plugins_alter().
 */
function ckeditor_inline_image_style_plugins_alter(&$plugins) {
  $path = backdrop_get_path('module', 'ckeditor_inline_image_style');
  $image_prefix = backdrop_get_path('module', 'ckeditor') . '/images/buttons/';

  // The backdropimage plugin replaces normal image functionality.
  $plugins['backdropimage'] = array(
    'path' => $path . '/ckeditor/plugins/backdropimage',
    'file' => 'plugin.js',
    'css' => array($path . '/css/ckeditor.css'),
    'buttons' => array(
      'BackdropImage' => array(
        'label' => t('Image'),
        'required_html' => array(
          array(
            'tags' => array('img'),
            'attributes' => array('src', 'alt', 'data-file-id', 'data-align'),
          ),
        ),
        'image' => $image_prefix . 'image.png',
      ),
    ),
  );

  // The backdropcaption plugin provides consistent behaviors for image captions.
  $plugins['backdropimagecaption'] = array(
    'path' => $path . '/ckeditor/plugins/backdropimagecaption',
    'file' => 'plugin.js',
    'css' => array($path . '/css/ckeditor.css'),
    'enabled callback' => 'ckeditor_image_plugin_check',
    'required_html' => array(
      array(
        'tags' => array('img'),
        'attributes' => array('data-caption'),
      ),
      array(
        'tags' => array('figure', 'figcaption'),
        'attributes' => array('src', 'alt', 'class', 'data-placeholder'),
      ),
    )
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Add settings for Ckeditor Inline Image Style plugin.
 */
function ckeditor_inline_image_style_form_filter_admin_format_form_alter(&$form, $form_state) {
  // Defaults.
  $settings
    = isset($form_state['format']->editor_settings['ckeditor_inline_image_style'])
    ? $form_state['format']->editor_settings['ckeditor_inline_image_style']
    : [];
  $settings += [
    'status' => FALSE,
    'image_styles' => [],
  ];

  $form['editor_settings']['plugins']['ckeditor_inline_image_style']
    = [
    '#type'       => 'fieldset',
    '#title'      => t("Inline Image Syles"),
    '#tree'       => TRUE,
    '#attributes' => [
      'class' => ['data-image-style'],
    ],
    '#parents'    => [
      'editor_settings',
      'ckeditor_inline_image_style',
    ],
  ];

  $form['editor_settings']['plugins']['ckeditor_inline_image_style']['status']
    = [
    '#type'          => 'checkbox',
    '#title'         => t("Enable"),
    '#default_value' => $settings['status'],
    '#description'   => t("Select image style in CKEditor."),
    '#attributes'    => [
      'data-editor-ckeditor_inline_image_style' => 'status',
    ],
  ];

  $show_if_ckeditor_inline_image_style_enabled = array(
    'visible' => array(
      ':input[data-editor-ckeditor_inline_image_style="status"]' => array('checked' => TRUE),
    ),
  );

  $image_styles = image_styles();
  $options = array();
  foreach ($image_styles as $image_style) {
    $options[$image_style['name']] = $image_style['label'];
  }

  $form['editor_settings']['plugins']['ckeditor_inline_image_style']['image_styles'] = array(
    '#title' => t('Select the image styles that are available inside CKEditor'),
    '#type' => 'checkboxes',
    '#options' => $options,
    '#default_value' => $settings['image_styles'],
    '#states' => $show_if_ckeditor_inline_image_style_enabled,
  );
}

/**
 * Implements hook_filter_info().
 */
function ckeditor_inline_image_style_filter_info() {
  $filters = [];
  $filters['ckeditor_inline_image_style'] = [
    'title'            => t('Make images support image styles'),
    'description'      => t(
      'Replace img tags with markup that contains the selected image style.'
    ),
    'process callback' => '_ckeditor_inline_image_style_filter_process',
  ];

  return $filters;
}

/**
 * Process callback for inline image filter.
 */
function _ckeditor_inline_image_style_filter_process($text) {
  // Find all img tags with a data-image-style attribute.
  preg_match_all('/<img [^>]*data-image-style\s*=\s*["\'][^>]*>/i', $text, $images);
  if (!empty($images[0])) {
    foreach ($images[0] as $image) {
      $image_render_array = _ckeditor_inline_image_style_filter_prepare_image($image);
      if (!$image_render_array) {
        continue;
      }
      // Extract the styled image URL, width, and height.
      $styled_image_url = $image_render_array['#path'];
      $styled_width = $image_render_array['#width'];
      $styled_height = $image_render_array['#height'];

      // Replace the src, width, and height attributes within the original image tag.
      $new_image = preg_replace('/src="[^"]*"/i', 'src="' . check_plain($styled_image_url) . '"', $image);
      $new_image = preg_replace('/width="[^"]*"/i', 'width="' . $styled_width . '"', $new_image);
      $new_image = preg_replace('/height="[^"]*"/i', 'height="' . $styled_height . '"', $new_image);

      // Replace the original img tag with the new one in the text.
      $text = str_replace($image, $new_image, $text);
    }
  }
  return $text;
}



/**
 * Prepares an image.
 */
function _ckeditor_inline_image_style_filter_prepare_image($image) {
  // Make sure the closing tag is right.
  $image = str_replace('/>', '>', $image);
  $image = str_replace('>', ' />', $image);
  $image = str_replace("&nbsp;", '', $image);
  $image = htmlspecialchars($image);
  // Parse the tag as XML.
  $xml = simplexml_load_string(
    '<image>' . html_entity_decode($image, ENT_QUOTES, "utf-8") . '</image>'
  );

  if (isset($xml->img[0]) && is_object($xml->img[0])) {
    $attributes = [];
    foreach ($xml->img[0]->attributes() as $a => $b) {
      $attributes[$a] = (string) $b;
    }
  }

  $image_style = FALSE;
  if (isset($attributes['data-image-style'])) {
    $image_style = $attributes['data-image-style'];
  }
  if (!$image_style) {
    return;
  }

  $image_styles = image_styles();
  if (!isset($image_styles[$image_style])) {
    return;
  }
  // Make sure we have a src attribute.
  if (!isset($attributes['src'])) {
    return FALSE;
  }

  $src = $attributes['src'];
  unset($attributes['src']);
  $alt = isset($attributes['alt']) ? $attributes['alt'] : '';
  unset($attributes['alt']);

  $title = isset($attributes['title']) ? $attributes['title'] : '';
  unset($attributes['title']);

  // Ensure that class attributes are properly split into an array.
  if (!empty($attributes['class']) && !is_array($attributes['class'])) {
    $attributes['class'] = array_filter(explode(' ', $attributes['class']));
  }

  // Make sure we have a valid image URI.
  $uri = ckeditor_inline_image_style_image_uri($src);
  if (!$uri) {
    return FALSE;
  }
  $image_info = image_get_info($uri);
  if (!$image_info) {
    // It's not an image.
    return FALSE;
  }

  if ($image_style != 'none') {
    $styled_image_url = image_style_url($image_style, $uri);
  } else {
    $styled_image_url = file_create_url($uri);
  }
  // Directly access styled image dimensions
  if ($image_style != 'none' && !empty($image_styles[$image_style]['effects'])) {
    $effect = reset($image_styles[$image_style]['effects']); // Assuming the first effect contains dimension data
    if (isset($effect['data']['width']) && isset($effect['data']['height'])) {
      $styled_width = $effect['data']['width'];
      $styled_height = $effect['data']['height'];
    }
  } else {
    $styled_image_url = file_create_url($uri);
    // Optionally, fall back to original dimensions if no style is applied
    $styled_width = $image_info['width'];
    $styled_height = $image_info['height'];
  }

  // Make sure we have valid dimensions and a styled image URL
  if (!isset($styled_width) || !isset($styled_height)) {
    return FALSE; // or handle the error as needed
  }

  if (!isset($styled_image_url)) {
    $styled_image_url = image_style_url($image_style, $uri);
  }
  // Construct the image render array using the styled dimensions.
  $image_render_array = [
    '#theme'      => 'image_style',
    '#style_name' => $image_style,
    '#path'       => $styled_image_url,
    '#width'      => $styled_width,
    '#height'     => $styled_height,
    '#alt'        => $alt,
    '#title'      => $title,
    '#attributes' => ['data-image-style' => $image_style] + $attributes,
  ];
  return $image_render_array;
}

/**
 * Helper function to figure out the uri of an image source.
 *
 * @param string $src
 *   Image src starting with http://, https://, or root relative /.
 */
function ckeditor_inline_image_style_image_uri($src) {
  foreach (
    module_implements('ckeditor_inline_image_style_image_uri') as $module
  ) {
    $function = $module . '_ckeditor_inline_image_style_image_uri';
    if ($uri = $function($src)) {
      $uri = file_stream_wrapper_uri_normalize($uri);
      return urldecode($uri);
    }
  }
  return FALSE;
}

/**
 * Implements hook_ckeditor_inline_image_style_image_uri().
 */
function ckeditor_inline_image_style_ckeditor_inline_image_style_image_uri($src) {
  global $base_path;

  // List all visible stream wrappers.
  $visible_stream_wrappers = array_intersect_key(
    file_get_stream_wrappers(STREAM_WRAPPERS_WRITE),
    file_get_stream_wrappers(STREAM_WRAPPERS_VISIBLE)
  );

  // Check if the src matches the S3 URL pattern.
  if (preg_match('/https:\/\/[a-zA-Z0-9\-]+\.s3\.[a-zA-Z0-9\-]+\.amazonaws\.com\/(.+)/', $src, $matches)) {
    // Extract the path from the S3 URL.
    $path = $matches[1];
    // Here, you could adjust the path as needed for your internal usage.
    // For example, using a custom stream wrapper format or a generic one.
    $uri = "s3://{$path}";
    return $uri;
  }


  // Proceed with modification for non-S3 URLs
  $uri = '';

  // Prepare the src by removing http:// or https://.
  $src = parse_url($src, PHP_URL_PATH);
  // Remove leading or trailing slashes.
  $src = trim($src, '/');
  $needles = [];
  $matches = [];
  foreach ($visible_stream_wrappers as $scheme => $data) {
    $class = file_stream_wrapper_get_class($scheme);
    $stream_wrapper = new $class();
    if (method_exists($stream_wrapper, 'getDirectoryPath')) {
      $needles[$scheme] = trim(
        $base_path . $stream_wrapper->getDirectoryPath(),
        '/'
      );

      // Check whether the file stream directory is at the beginning of
      // the image src. Use === since strpos could return false.
      if (!empty($needles[$scheme]) && strpos($src, $needles[$scheme]) === 0) {
        $matches[$scheme] = $needles[$scheme];
      }
    }
  }

  // No file stream wrapper is starting with the image src.
  // So it's not a public file.
  if (empty($matches)) {
    // Check for managed/private file with relative path like system/files/..
    $src_exploded = explode('/', $src);
    if ($src_exploded[0] == 'system' && $src_exploded[1] == 'files') {
      // Managed/private file recognized.
      // Check for image style derivatives.
      if ($src_exploded[2] == 'styles') {
        // Image style recognized.
        $unwanted_part = 'system/files/styles/' . $src_exploded[3]
          . '/private/';
        $uri = str_replace($unwanted_part, 'private://', $src);
        $uri = file_stream_wrapper_uri_normalize($uri);
        return urldecode($uri);
      }
      else {
        // No image style recognized; must be an original.
        $unwanted_part = 'system/files/';
        $uri = str_replace($unwanted_part, 'private://', $src);
        $uri = file_stream_wrapper_uri_normalize($uri);
        return urldecode($uri);
      }
    }
    else {
      // Can't figure out the Backdrop uri.
      return FALSE;
    }
  }

  // If one file scheme directory is a subdirectory of another file
  // scheme directory, choose the longer one. This issue is possible with
  // the following scenario:
  // public file dir: /sites/default/files/
  // private file dir: /sites/default/files/private/
  // image src: /sites/default/files/private/the-image.jpg
  // In this example, the intended scheme would be 'private'.
  if (empty($matches)) {
    // Can't figure out the Backdrop uri.
    return FALSE;
  }

  // Find the length of each matching directory path.
  $lengths = array_map('strlen', $matches);

  // Determine the key of the longest one.
  $the_scheme = array_search(max($lengths), $lengths);
  // Construct the Backdrop uri.
  $uri = $the_scheme . '://' . str_replace($matches[$the_scheme], '', $src);
  return $uri;
}

/**
 * Implements hook_library_info_alter().
 */
function ckeditor_inline_image_style_library_info_alter(&$libraries, $module) {
  $module_path = backdrop_get_path('module', 'ckeditor5');
  // Check if the CKEditor 5 module's libraries are being altered
  if ($module == 'ckeditor5' && isset($libraries['backdrop.ckeditor5.backdrop-image'])) {
    $path = backdrop_get_path('module', 'ckeditor_inline_image_style')
      . '/ckeditor5/plugins/backdrop-image/backdrop-image.js';


    // Correctly structure the JS array to include the custom plugin script
    // Note: Adjusting to the correct format as per Backdrop documentation
    $libraries['backdrop.ckeditor5.backdrop-image']['js'][$path] = array('group' => JS_LIBRARY, 'weight' => 5);

  }
}

/**
 * Implements hook_ckeditor5_plugins_alter().
 */
function ckeditor_inline_image_style5_plugins_alter(array &$plugins) {
  $image_prefix = backdrop_get_path('module', 'ckeditor5') . '/icons/';
  // The BackdropImage plugin extends the default CKEditor Image plugin.
  $plugins['backdropImage.BackdropImage'] = [
    'library' => ['ckeditor5', 'backdrop.ckeditor5.backdrop-image'],
    'buttons' => [
      'backdropImage' => [
        'label'               => t('Image'),
        'plugin_dependencies' => [
          'image.Image',
          'image.ImageToolbar',
          'image.ImageInsertUI',
          'image.ImageUpload',
          'image.ImageResize',
          'image.ImageCaptionUtils',
        ],
        'required_html'       => [
          '<img src alt height width data-file-id data-image-style>',
        ],
        'image'               => $image_prefix . '/image.svg',
      ],
    ],
    'config'  => [
      'image'         => [
        // Configure the balloon toolbar items shown when an image is selected.
        'toolbar'    => [
          'imageTextAlternative',
          'editBackdropImage',
        ],
        'upload'     => [
          'type' => image_get_supported_extensions(),
        ],
        'resizeUnit' => 'px',
      ],
      'backdropImage' => [
        'editLabel'       => t('Edit Image'),
        'insertLabel'     => t('Insert Image'),
        // Specify an array of CKEditor model name => attribute name values.
        // These attributes are then allowed to be changed via the Backdrop
        // image dialog. Additional attributes can be added here to prevent
        // CKEditor from striping out attributes on img tags.
        'extraAttributes' => [
          'dataFileId' => 'data-file-id',
          'alt'        => 'alt',
          'src'        => 'src',
          'width'      => 'width',
          'height'     => 'height',
        ],
      ],
    ],
  ];
}
